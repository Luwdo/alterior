<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>@alterior/web-server</title>
	<meta name="description" content="Documentation for @alterior/web-server">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">@alterior/web-server</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>@alterior/web-server</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#alteriorweb-server" id="alteriorweb-server" style="color: inherit; text-decoration: none;">
					<h1>@alterior/web-server</h1>
				</a>
				<p><a href="https://www.npmjs.com/package/@alterior/web-server"><img src="https://img.shields.io/npm/v/@alterior/web-server.svg" alt="Version"></a></p>
				<p>A framework for building HTTP services in Typescript. Build REST APIs with this. </p>
				<a href="#getting-started" id="getting-started" style="color: inherit; text-decoration: none;">
					<h1>Getting started</h1>
				</a>
				<p>Install the Alterior runtime, the DI library, and the web-server module:</p>
				<pre><code><span class="hljs-built_in">npm</span> install reflect-metadata
<span class="hljs-built_in">npm</span> install @alterior/runtime @alterior/di @alterior/web-server</code></pre>
				<a href="#configuring-typescript" id="configuring-typescript" style="color: inherit; text-decoration: none;">
					<h1>Configuring Typescript</h1>
				</a>
				<p>You must enable <code>enableExperimentalDecorators</code> and <code>emitDecoratorMetadata</code>,
					and <code>esModuleInterop</code> Typescript compiler options to use this library. Do
				this within <code>tsconfig.json</code>:</p>
				<pre><code class="language-json">{
    <span class="hljs-attr">&quot;compilerOptions&quot;</span>: {
        <span class="hljs-attr">&quot;enableExperimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">&quot;esModuleInterop&quot;</span>: <span class="hljs-literal">true</span>
    }
}</code></pre>
				<a href="#a-minimal-example" id="a-minimal-example" style="color: inherit; text-decoration: none;">
					<h1>A minimal example</h1>
				</a>
				<p>For simple use cases, you can build a web service using Alterior in a single file:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// my-web-service.ts</span>

<span class="hljs-keyword">import</span> { WebService } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@alterior/web-server&#x27;</span>;

<span class="hljs-meta">@WebService</span>({
    <span class="hljs-attr">providers</span>: []
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebService</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>{
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/version&#x27;</span>)
    <span class="hljs-function"><span class="hljs-title">version</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;1.0.0&quot;</span> };
    }

    <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/&#x27;</span>)
    <span class="hljs-function"><span class="hljs-title">version</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">hello</span>: <span class="hljs-string">&#x27;world&#x27;</span> };
    }
}

Application.bootstrap(MyWebService);</code></pre>
				<a href="#how-do-i-run-it" id="how-do-i-run-it" style="color: inherit; text-decoration: none;">
					<h1>How do I run it?</h1>
				</a>
				<p>Make an entry point for your application if you don&#39;t already have one:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// main.ts </span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;reflect-metadata&#x27;</span>;

<span class="hljs-keyword">import</span> { Application } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@alterior/runtime&#x27;</span>;
<span class="hljs-keyword">import</span> { MyWebService } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./my-web-service&#x27;</span>;

Application.bootstrap(MyWebService);</code></pre>
				<p>After you compile your application using Typescript, run your app using Node.js:</p>
				<pre><code><span class="hljs-keyword">node</span> <span class="hljs-title">dist</span>/main</code></pre><p>You should use NPM scripts to manage building, testing and running your application per the conventions of the Node.js community.</p>
				<a href="#mechanics-of-webservice" id="mechanics-of-webservice" style="color: inherit; text-decoration: none;">
					<h1>Mechanics of <code>@WebService</code></h1>
				</a>
				<p>When classes marked <code>@WebService()</code> are bootstrapped as part of an Alterior application (via <code>Application#bootstrap()</code>), a new Alterior role is registered with <a href="../runtime/README.md#roles"><code>RolesService</code></a> which is responsible for starting up and shutting down a web server using one of the supported WebEngines (currently Express and Fastify). The class itself acts both as a <code>@Module()</code> and the root <code>@Controller()</code> of the service. The class can then use <code>@Mount()</code> to add additional controllers to the service. Each <code>@WebService()</code> has its own separate server instance, which means you can host multiple web services (on different ports) within the same overall application. Each service will be given its own role which can be controlled independently.</p>
				<a href="#delegation-via-mounting" id="delegation-via-mounting" style="color: inherit; text-decoration: none;">
					<h1>Delegation via Mounting</h1>
				</a>
				<p>You can delegate parts of your web service to dedicated controllers by mounting them within your main service class. Doing so will route specific URLs to specific controllers. Any controller can <code>@Mount()</code>, providing an intuitive way to construct a complete web service from a tree of controllers:</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@WebService</span>(...)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebService</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>{
    <span class="hljs-meta">@Mount</span>(<span class="hljs-string">&#x27;/users&#x27;</span>)
    <span class="hljs-attr">usersController</span> : UsersController;

    <span class="hljs-meta">@Mount</span>(<span class="hljs-string">&#x27;/some-plugin&#x27;</span>)
    <span class="hljs-attr">somePlugin</span> : SomePluginController;
}</code></pre>
				<p>When you nest controllers using <code>@Mount()</code>, each subcontroller inherits the path prefix defined by all parents, like below:</p>
				<pre><code class="language-typescript">
<span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;/f&#x27;</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSubController</span> </span>{
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/g&#x27;</span>)
    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;you requested: GET /a/b/c/d/e/f/g&#x27;</span> };
    }
}

<span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;/c&#x27;</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubController</span> </span>{
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/d&#x27;</span>)
    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;you requested: GET /a/b/c/d&#x27;</span> };
    }

    <span class="hljs-meta">@Mount</span>(<span class="hljs-string">&#x27;/e&#x27;</span>)
    <span class="hljs-attr">subsub</span> : SubSubController;
}

<span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;/a&#x27;</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainController</span> </span>{
    <span class="hljs-meta">@Mount</span>(<span class="hljs-string">&#x27;/b&#x27;</span>)
    <span class="hljs-attr">sub</span> : SubController;
}</code></pre>
				<p>Note: You do not always have to specify a path for <code>@Controller()</code>, <code>@Mount()</code> or <code>@Get()</code>, we have done so here for to keep the example clear. If you omit a path or set it to <code>&#39;&#39;</code>, the element will not contribute any path segments to the final path registered for your routes.</p>
				<a href="#when-to-use-base-paths-with-mount" id="when-to-use-base-paths-with-mount" style="color: inherit; text-decoration: none;">
					<h1>When to use base paths with @Mount</h1>
				</a>
				<p>To ensure your app is easy to maintain as it grows, we recommend that you design your mounted controllers to operate from the root of your web service. This means omitting a base path when using <code>@Mount()</code>. Doing so ensures that you will not need to rewrite all of your route definitions if you need to add a route that falls outside of your controller&#39;s expected base path.</p>
				<p>Passing a base path can be useful however when consuming a controller which is intended to be consumed by many web services.</p>
				<a href="#promises-amp-async" id="promises-amp-async" style="color: inherit; text-decoration: none;">
					<h1>Promises &amp; Async</h1>
				</a>
				<pre><code class="language-typescript"><span class="hljs-comment">/**
 * You can return promises. Alterior will wait for the promise to resolve
 * before responding to the HTTP request.
 */</span>
<span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/promises&#x27;</span>)
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">canUsePromises</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve({ <span class="hljs-attr">nifty</span>: <span class="hljs-number">123</span> });
}

<span class="hljs-comment">/**
 * Or use async/await (the recommended way!)
 */</span>
<span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/async&#x27;</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">canUseAsync</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> someFunction();
}</code></pre>
				<a href="#path-parameters" id="path-parameters" style="color: inherit; text-decoration: none;">
					<h1>Path Parameters</h1>
				</a>
				<p>The parameters specified by your route methods are automatically
					analyzed, and the correct value is provided depending on what type
				(and in some cases what name) your parameter has.</p>
				<p>For example, you can receive path parameters. Alterior knows that
					since you have a path parameter named <code>nameOfCar</code> and an otherwise
					undecorated method parameter also named <code>nameOfCar</code> that these two are
				related </p>
				<pre><code class="language-typescript"><span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/cars/:nameOfCar&#x27;</span>)
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">canUseRouteParams</span>(<span class="hljs-params">nameOfCar : <span class="hljs-built_in">string</span></span>)</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`you asked for car named <span class="hljs-subst">${nameOfCar}</span>`</span>;
}</code></pre>
				<a href="#accessing-the-requestresponse" id="accessing-the-requestresponse" style="color: inherit; text-decoration: none;">
					<h1>Accessing the Request/Response</h1>
				</a>
				<p>Sometimes you need to check or set an HTTP header, interact directly with middleware, or handle parsing the request body or serializing the response body yourself. Alterior lets you do that using the <code>RouteEvent</code> class. </p>
				<pre><code class="language-typescript"><span class="hljs-meta">@Get</span>()
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">whoAmI</span>(<span class="hljs-params"></span>)</span> {
    RouteEvent.response.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">`hello <span class="hljs-subst">${RouteEvent.request.header(<span class="hljs-string">&#x27;user-agent&#x27;</span>)}</span>`</span>);
}</code></pre>
				<a href="#is-this-done-via-global-variables-wouldn39t-that-not-work-with-async-requests" id="is-this-done-via-global-variables-wouldn39t-that-not-work-with-async-requests" style="color: inherit; text-decoration: none;">
					<h2>Is this done via global variables? Wouldn&#39;t that not work with async requests?</h2>
				</a>
				<p><code>RouteEvent</code> uses Zone-local variables to accomplish its task, so there is no risk that you will access the wrong request/response when using it unlike when global variables are used for this purpose. </p>
				<a href="#complex-responses" id="complex-responses" style="color: inherit; text-decoration: none;">
					<h1>Complex Responses</h1>
				</a>
				<p>The recommended way to handle HTTP error statuses is using the <code>HttpException</code> class. You can throw the exception from your route method and Alterior will recognize this and fulfill the HTTP response as you specify.</p>
				<pre><code class="language-typescript"><span class="hljs-comment">/**
 * Promises can reject with an HttpException to specify HTTP errors...
 */</span>
<span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/error&#x27;</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">errorExample</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpException(<span class="hljs-number">301</span>, {<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;No, over there&quot;</span>}));
}</code></pre>
				<p>For successful responses, throwing HttpException (while supported) is not idiomatic. Instead you should return a special response value from your method using the <code>Response</code> class</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@Get</span>()
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">responseExample</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">return</span> Response.movedPermanently(<span class="hljs-string">&#x27;https://example.com/&#x27;</span>);
}</code></pre>
				<a href="#parameters-matching" id="parameters-matching" style="color: inherit; text-decoration: none;">
					<h1>Parameters Matching</h1>
				</a>
				<p>Alterior inspects the parameters of controller methods to determine what values need to be provided while handling a request. </p>
				<ul>
					<li>Parameters decorated with <code>@PathParam(&#39;a&#39;)</code> will be fulfilled with the value
						of path parameter <code>:a</code> from the route path (as in <code>/some/path/:a</code>). The
					path parameter can be defined in any parent controller/mount context. Since path parameters are the most common, and there is a high degree of linkage between path parameters and method parameters, you can omit <code>@PathParam()</code> if the name of your path parameters is the same as your method parameter as shown above</li>
					<li>Parameters decorated with <code>@QueryParam(&#39;q&#39;)</code> will be fulfilled with the query
					parameter <code>q</code> if provided (<code>?q=...</code>). If the query parameter was not provided in the request, the value of the parameter will be <code>undefined</code>.</li>
					<li>Parameters which are decorated with <code>@Body()</code> will be fulfilled
					with the value of <code>RouteEvent.request.body</code>. If the type of the method parameter is <code>string</code>, Alterior will automatically connect a text body parsing middleware (<code>bodyParser.text()</code>). If the type of the method parameter is <code>Buffer</code>, Alterior will automatically connect a raw body parsing middleware (<code>bodyParser.raw()</code>). For any other parameter type, Alterior adds a JSON body parsing middleware (<code>bodyParser.json()</code>). If you need other body parsing middleware, you can add it directly to the <code>middleware</code> property of the route decorator&#39;s <code>options</code> parameter and use <code>RouteEvent.request.body</code> directly instead.</li>
				</ul>
				<blockquote>
					<p>Note: If a path parameter is defined directly in the path passed to <code>@Get()</code>
						decorator and an (otherwise unfulfilled) parameter with the same name is
						defined on the method, the method parameter is fulfilled with the path parameter
						for the current request. Method parameters meant to be fulfilled from any
					parent controller/mount-defined parameters must be decorated with <code>@PathParam()</code></p>
				</blockquote>
				<p>When combined with value returns, you can achieve a very natural style:  </p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> bodyParser <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;body-parser&#x27;</span>;

<span class="hljs-keyword">interface</span> MyRequestType {
    <span class="hljs-attr">action</span> : <span class="hljs-built_in">string</span>;
    foo? : <span class="hljs-built_in">number</span>;
}

<span class="hljs-meta">@Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>{
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/do/:action&#x27;</span>)
    <span class="hljs-function"><span class="hljs-title">doThings</span>(<span class="hljs-params">
        <span class="hljs-meta">@Body</span>() body : MyRequestType, 
        <span class="hljs-meta">@PathParam</span>(<span class="hljs-string">&#x27;action&#x27;</span>) action : <span class="hljs-built_in">string</span>, 
        <span class="hljs-meta">@QueryParam</span>(<span class="hljs-string">&#x27;message&#x27;</span>) message : <span class="hljs-built_in">string</span>
    </span>)</span> {
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">status</span>: <span class="hljs-string">&quot;success&quot;</span>};
    }
}</code></pre>
				<a href="#websockets" id="websockets" style="color: inherit; text-decoration: none;">
					<h1>WebSockets</h1>
				</a>
				<p>WebSocket support is built in. You can call <code>WebServer.startSocket()</code> while handling a request to upgrade the current request into a WebSocket connection.</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@Get</span>()
<span class="hljs-function"><span class="hljs-title">mySocket</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">let</span> socket = WebServer.startSocket();
    socket.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Received message from client: <span class="hljs-subst">${ev.data}</span>`</span>);
    });
}</code></pre>
				<a href="#tls-https" id="tls-https" style="color: inherit; text-decoration: none;">
					<h1>TLS (HTTPS)</h1>
				</a>
				<p>Typically it is best to terminate HTTPS at a reverse proxy running on the same machine as your application server, or at an external load balancer. However Alterior does allow you to do it within the application server (which is required for native HTTP/2)</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@WebService</span>({
    <span class="hljs-attr">server</span>: {
        <span class="hljs-attr">certificate</span>: <span class="hljs-string">`---BEGIN...`</span>,
        <span class="hljs-attr">privateKey</span>: <span class="hljs-string">`---BEGIN...`</span>,
        <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>
    }
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
				<a href="#http2" id="http2" style="color: inherit; text-decoration: none;">
					<h1>HTTP/2</h1>
				</a>
				<p>HTTP/2 support is built-in. Specify <code>protocols</code> to enable it. If you provide a TLS certificate HTTP/2 is enabled by default. Otherwise only HTTP is enabled. However, if you add <code>h2</code> (or one of the <code>spdy/*</code> versions) to <code>protocols</code> but you do not specify a TLS certificate, then Alterior will automatically generate and use a self-signed certificate which is useful for testing HTTP/2 services in development.</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@WebService</span>({
    <span class="hljs-attr">server</span>: {
        <span class="hljs-attr">protocols</span>: [<span class="hljs-string">`h2`</span>, <span class="hljs-string">`spdy/3.1`</span>, <span class="hljs-string">`spdy/3`</span>, <span class="hljs-string">`spdy/2`</span>, <span class="hljs-string">`http/1.1`</span>, <span class="hljs-string">`http/1.0`</span>]
    }
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
				<a href="#server-sent-events" id="server-sent-events" style="color: inherit; text-decoration: none;">
					<h1>Server-Sent Events</h1>
				</a>
				<p>You can use <code>RouteEvent.sendEvent()</code> to send an event stream response back to the client. For more information about
				server-sent events, see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events</a></p>
				<p>The <code>data</code> field is serialized into JSON for you. Note that Server-Sent Events over HTTP/1.1 is not ideal as modern
				browsers only allow a maximum of six (6) connections to a given server. However, <a href="#http2">with HTTP/2</a> this is not an issue.</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/sse&#x27;</span>)
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">sse</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">while</span> (RouteEvent.connected) {
        <span class="hljs-keyword">await</span> timeout(<span class="hljs-number">1000</span>);
        <span class="hljs-keyword">await</span> RouteEvent.sendEvent({ <span class="hljs-attr">event</span>: <span class="hljs-string">&#x27;ping&#x27;</span>, <span class="hljs-attr">data</span>: { <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;are you still there?&#x27;</span> } });
    }
}</code></pre>
				<a href="#dependency-injection" id="dependency-injection" style="color: inherit; text-decoration: none;">
					<h1>Dependency Injection</h1>
				</a>
				<p>Modules, controllers and services all participate in dependency injection. For more information about how DI works in Alterior apps, see the documentation for <a href="../di/README.md">@alterior/di</a>.</p>
				<a href="#middleware" id="middleware" style="color: inherit; text-decoration: none;">
					<h1>Middleware</h1>
				</a>
				<p>Alterior supports Connect middleware (as used in Express, Fastify, etc). Middleware can be connected globally or
				declared as part of a route. </p>
				<p>To add middleware globally you can declare the <code>middleware</code> property on your <code>@WebService</code> or via
				<code>WebServerModule.configure()</code>.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myConnectMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my-connect-middleware&#x27;</span>;
<span class="hljs-meta">@WebService</span>({
    <span class="hljs-attr">middleware</span>: [myConnectMiddleware()]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
				<p>You can also connect middleware globally, but limit it to specific paths:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> fileUpload = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-fileupload&#x27;</span>);

<span class="hljs-meta">@WebService</span>({
    <span class="hljs-attr">middleware</span>: [
        [<span class="hljs-string">&#x27;/files&#x27;</span>, fileUpload]
    ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>{
    <span class="hljs-comment">// ...</span>
}</code></pre>
				<p>To add route-specific middleware, use the <code>middleware</code> property of the options object:</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, { <span class="hljs-attr">middleware</span>: [fileUpload] })
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">getFoo</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-comment">// ...</span>
}</code></pre>
				<p>Middleware is inherited from parent controllers when using <code>@Mount()</code>,
					you can use this to avoid repeating yourself when building more complex
				services:</p>
				<pre><code class="language-typescript">    <span class="hljs-meta">@Controller</span>()
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeatureController</span> </span>{
        <span class="hljs-meta">@Get</span>() 
        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> {
            <span class="hljs-comment">// corsExampleMiddleware runs for this and all requests on this</span>
            <span class="hljs-comment">// controller </span>

            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">service</span>: <span class="hljs-string">&#x27;feature&#x27;</span>
            }
        }
    }

    <span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;&#x27;</span>, { 
        <span class="hljs-attr">middleware</span>: [ 
            corsExampleMiddleware({ <span class="hljs-attr">allowOrigin</span>: <span class="hljs-string">&#x27;*&#x27;</span> }) 
        ]
    })
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiController</span> </span>{
        <span class="hljs-meta">@Mount</span>(<span class="hljs-string">&#x27;/feature&#x27;</span>)
        <span class="hljs-attr">feature</span> : FeatureController;
    }</code></pre>
				<a href="#uncaught-exceptions" id="uncaught-exceptions" style="color: inherit; text-decoration: none;">
					<h1>Uncaught Exceptions</h1>
				</a>
				<p>When an exception occurs while executing a controller route method (excluding HttpExceptions), Alterior will respond
					with an HTTP 500 error. By default, exception information will be included with the response. If the caught exception
					has a <code>toString()</code> method, it will be executed and its return value will be sent. If it does not, the error object will
				be included directly, being converted along with the rest of the response to JSON.</p>
				<p><code>throw new Error(&#39;This is the error text&#39;)</code> would produce:</p>
				<pre><code class="language-json">{
    <span class="hljs-attr">&quot;message&quot;</span>:<span class="hljs-string">&quot;An exception occurred while handling this request.&quot;</span>,
    <span class="hljs-attr">&quot;error&quot;</span>:<span class="hljs-string">&quot;Error: This is the error text\n    at FooController.sampleRequest (music.js:36:29)&quot;</span>
}</code></pre>
				<p><code>throw { foo: &#39;bar&#39; }</code> would product:</p>
				<pre><code class="language-json">{<span class="hljs-attr">&quot;message&quot;</span>:<span class="hljs-string">&quot;An exception occurred while handling this request.&quot;</span>,<span class="hljs-attr">&quot;error&quot;</span>:{<span class="hljs-attr">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>}}</code></pre>
				<p>You can disable the inclusion of exception information in responses (and this is recommended for production).
				To do so, set <code>WebServerOptions.hideExceptions</code> to <code>true</code>. The <code>error</code> field will then be excluded from 500 responses.</p>
				<pre><code class="language-json">{<span class="hljs-attr">&quot;message&quot;</span>:<span class="hljs-string">&quot;An exception occurred while handling this request.&quot;</span>}</code></pre>
				<a href="#sessions" id="sessions" style="color: inherit; text-decoration: none;">
					<h1>Sessions</h1>
				</a>
				<p>WARNING: Generally APIs should not use cookies. If your API is used by a by a browser application (which is the main reason you would use cookies in the first place), it is essential that you restrict the allowed origins of your API using CORS to ensure that other (potentially malicious) origins cannot request your API using credentials saved in the browser of your authorized users. Known as Cross Site Request Forgery (CSRF), this is a serious security vulnerability and it should be treated with care. </p>
				<p>It is far better to use the <code>Authorization</code> header to pass an explicit auth token and if necessary correlate that token to a server-managed session instead. Authorization headers are managed by the calling application, not by the user agent and are not automatically sent with requests to your API. Doing so can avoid many of the pitfalls that using cookies can cause. </p>
				<p>Nonetheless, if you understand the security risks and have taken the proper precautions, it is possible to use cookie-driven sessions with Alterior, though managing the session itself is not included by default.</p>
				<p>To add session support, use <code>express-session</code>:</p>
				<pre><code>npm i express-<span class="hljs-keyword">session</span> <span class="hljs-comment">--save</span>
npm i @<span class="hljs-keyword">types</span>/express-<span class="hljs-keyword">session</span> <span class="hljs-comment">--save-dev</span></code></pre><p>Include it as middleware:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> session <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express-session&#x27;</span>;
<span class="hljs-meta">@WebService</span>({
    <span class="hljs-attr">middleware</span>: [session({ <span class="hljs-attr">secret</span>: SESSION_SECRET })]
})</code></pre>
				<p>You can then use the session via the <code>Session</code> class which is provided for you. The simplest way to use it is via the <code>get()</code> and <code>set()</code> methods:</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@Controller</span>()
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleController</span> </span>{
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/&#x27;</span>)
    <span class="hljs-function"><span class="hljs-title">home</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> Session.current.get(<span class="hljs-string">&#x27;cartTotal&#x27;</span>);
    }
}</code></pre>
				<p>Using <code>get()</code> and <code>set()</code> provide no benefits via Typescript. The <code>Session</code> class can be subclassed however:</p>
				<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySession</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Session</span> </span>{
    <span class="hljs-attr">cartTotal</span> : <span class="hljs-built_in">number</span>;
}</code></pre>
				<p>You can then access that session from within your route methods like so:</p>
				<pre><code class="language-typescript">MySession.current.cartTotal</code></pre>
				<p>Note that both <code>Session.current</code> and <code>MySession.current</code> only have meaning when called from within a route method while an HTTP request is being processed. </p>
				<a href="#testing" id="testing" style="color: inherit; text-decoration: none;">
					<h1>Testing</h1>
				</a>
				<p>Use <code>teststrap()</code> to test endpoints in your web service. Since the caller and the server are in the same process, the actual HTTP server is skipped, with requests passed directly from the <code>teststrap()</code> test to an instance of your web service.</p>
				<p><code>teststrap()</code> uses <a href="https://github.com/visionmedia/supertest">supertest</a> as its core testing mechanism. The type of values returned by <code>teststrap()</code> is <code>supertest.Supertest&lt;supertest.Test&gt;</code>.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { teststrap } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@alterior/web-server/dist/testing&#x27;</span>;

<span class="hljs-meta">@WebService</span>()
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleService</span> </span>{ 
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;/&#x27;</span>)
    <span class="hljs-function"><span class="hljs-title">info</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;example&#x27;</span>, <span class="hljs-attr">version</span>: <span class="hljs-string">&#x27;1.0&#x27;</span> };
    }
}

<span class="hljs-comment">// suite/it/describe are from razmin (https://github.com/rezonant/razmin)</span>
<span class="hljs-comment">// you could use any test framework to encapsulate the </span>
<span class="hljs-comment">// teststrap() assertions.</span>

suite(<span class="hljs-function"><span class="hljs-params">describe</span> =&gt;</span> {
    describe(<span class="hljs-string">&#x27;ExampleService&#x27;</span>, <span class="hljs-function"><span class="hljs-params">it</span> =&gt;</span> {
        it(<span class="hljs-string">&#x27;returns its name&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
            <span class="hljs-keyword">await</span> teststrap(ExampleService)
                .get(<span class="hljs-string">&#x27;/&#x27;</span>)
                .expect(<span class="hljs-number">200</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;example&#x27;</span>, <span class="hljs-attr">version</span>: <span class="hljs-string">&#x27;1.0&#x27;</span> })
        });
    });
});</code></pre>
				<p>You can reuse a <code>teststrap()</code> test should you need to perform multiple requests in your tests:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">let</span> test = teststrap(ExampleService);

<span class="hljs-keyword">await</span> test.get(<span class="hljs-string">&#x27;/&#x27;</span>)
    .expect(<span class="hljs-number">200</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;example&#x27;</span>, <span class="hljs-attr">version</span>: <span class="hljs-string">&#x27;1.0&#x27;</span> })
;

<span class="hljs-keyword">await</span> test.get(<span class="hljs-string">&#x27;/foo&#x27;</span>)
    .expect(<span class="hljs-number">200</span>, { <span class="hljs-attr">other</span>: <span class="hljs-number">123</span> })
;</code></pre>
				<p><code>supertest</code> offers a number of convenient expectations, but sometimes you need to do something more complex:</p>
				<pre><code class="language-typescript">    <span class="hljs-keyword">import</span> { expect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;chai&#x27;</span>;

    <span class="hljs-keyword">let</span> res : express.Response = <span class="hljs-keyword">await</span> teststrap(ExampleService)
        .get(<span class="hljs-string">&#x27;/&#x27;</span>)
        .expect(<span class="hljs-number">200</span>)
    ;

    expect(res.body).to.contain({ <span class="hljs-attr">name</span>: })</code></pre>
				<p>For more information about the capabilities of <code>teststrap()</code>, consult the <a href="https://github.com/visionmedia/supertest">supertest documentation</a>.</p>
				<a href="#accessing-the-express-instance" id="accessing-the-express-instance" style="color: inherit; text-decoration: none;">
					<h1>Accessing the Express instance</h1>
				</a>
				<p>Perhaps you need access to the Express (or other web engine) application object to do something Alterior doesn&#39;t support:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span>
<span class="hljs-meta">@WebService</span>()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">
    </span>)</span> {
        <span class="hljs-keyword">let</span> server = WebServer.for(<span class="hljs-built_in">this</span>);
        <span class="hljs-built_in">this</span>.expressApp = server.engine.app;
        <span class="hljs-built_in">this</span>.expressApp.get(<span class="hljs-string">&#x27;/something&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
            res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">&#x27;/something works!&#x27;</span>);
        });
    }

    <span class="hljs-keyword">private</span> expressApp : express.Application;
}</code></pre>
				<p>You can call <code>WebServer.for()</code> and pass any web service or any controller mounted within a web service. Always pass the object instance (<code>this</code>) in order to ensure you get the correct web server instance. Note that if your controller is used in multiple web services, different instances of your controller will correspond to different instances of <code>WebServer</code>. </p>
				<a href="#deploying-to-a-cloud-function" id="deploying-to-a-cloud-function" style="color: inherit; text-decoration: none;">
					<h1>Deploying to a Cloud Function</h1>
				</a>
				<p>You can deploy an Alterior web service as a Cloud Function (Google Cloud Functions, AWS Lambda, or other Function-as-a-Service (FaaS) providers) using <code>WebServer.bootstrapCloudFunction()</code>:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// main.ts</span>

<span class="hljs-keyword">import</span> { MyWebService } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./my-web-service&#x27;</span>;
<span class="hljs-keyword">import</span> { WebServer } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@alterior/web-server&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> cloudFunction = WebServer.bootstrapCloudFunction(MyWebService);</code></pre>
				<p><code>bootstrapCloudFunction()</code> will handle constructing a function which takes an Express <code>request</code> and <code>response</code> and routes the given <code>request</code> through the given Alterior WebService module and populating data into <code>response</code>. This is suitable for exporting into a general cloud function environment like GCF or Lambda. </p>
				<p>Note: You can only pass a <code>@WebService()</code> class (ie, the top level of your web service). You cannot pass a <code>@Controller()</code> class, as controllers by themselves are not Alterior modules, and do not automatically </p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class">
						<a href="classes/certificategenerator.html" class="tsd-kind-icon">Certificate<wbr>Generator</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/controllerannotation.html" class="tsd-kind-icon">Controller<wbr>Annotation</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/controllerinstance.html" class="tsd-kind-icon">Controller<wbr>Instance</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/expressengine.html" class="tsd-kind-icon">Express<wbr>Engine</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/fastifyengine.html" class="tsd-kind-icon">Fastify<wbr>Engine</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/inputannotation.html" class="tsd-kind-icon">Input<wbr>Annotation</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/inputoptions.html" class="tsd-kind-icon">Input<wbr>Options</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/middlewareannotation.html" class="tsd-kind-icon">Middleware<wbr>Annotation</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/openapicontroller.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Controller</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/perfcomparison.html" class="tsd-kind-icon">Perf<wbr>Comparison</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/response.html" class="tsd-kind-icon">Response</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/routeevent.html" class="tsd-kind-icon">Route<wbr>Event</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/routeinstance.html" class="tsd-kind-icon">Route<wbr>Instance</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/routemethodparameter.html" class="tsd-kind-icon">Route<wbr>Method<wbr>Parameter</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/routereflector.html" class="tsd-kind-icon">Route<wbr>Reflector</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/server.html" class="tsd-kind-icon">Server</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/servicedescriptionref.html" class="tsd-kind-icon">Service<wbr>Description<wbr>Ref</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/session.html" class="tsd-kind-icon">Session</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/webserver.html" class="tsd-kind-icon">Web<wbr>Server</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/webserverengine.html" class="tsd-kind-icon">Web<wbr>Server<wbr>Engine</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/webserverref.html" class="tsd-kind-icon">Web<wbr>Server<wbr>Ref</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/webserversetuperror.html" class="tsd-kind-icon">Web<wbr>Server<wbr>Setup<wbr>Error</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/webserviceannotation.html" class="tsd-kind-icon">Web<wbr>Service<wbr>Annotation</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/controllercontext.html" class="tsd-kind-icon">Controller<wbr>Context</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/controlleroptions.html" class="tsd-kind-icon">Controller<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/fileupload.html" class="tsd-kind-icon">File<wbr>Upload</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/generatedcertificate.html" class="tsd-kind-icon">Generated<wbr>Certificate</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/generatoroptions.html" class="tsd-kind-icon">Generator<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/mountdefinition.html" class="tsd-kind-icon">Mount<wbr>Definition</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/mountoptions.html" class="tsd-kind-icon">Mount<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapicomponents.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Components</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapicontact.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Contact</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapidefinitionproperty.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Definition<wbr>Property</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapidefinitionpropertymap.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Definition<wbr>Property<wbr>Map</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/openapimap.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Map</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapioperation.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Operation</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapiparameter.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Parameter</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapiresponse.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Response</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapiresponsemap.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Response<wbr>Map</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapischema.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Schema</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapischemaref.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Schema<wbr>Ref</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapisecuritydefinition.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Security<wbr>Definition</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapisecuritydefinitionmap.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Security<wbr>Definition<wbr>Map</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapiservice.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Service</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapiserviceinfo.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Service<wbr>Info</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/openapitag.html" class="tsd-kind-icon">Open<wbr>Api<wbr>Tag</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/routedefinition.html" class="tsd-kind-icon">Route<wbr>Definition</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/routedescription.html" class="tsd-kind-icon">Route<wbr>Description</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/routemethodmetadata.html" class="tsd-kind-icon">Route<wbr>Method<wbr>Metadata</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/routeoptions.html" class="tsd-kind-icon">Route<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/routeparamdescription.html" class="tsd-kind-icon">Route<wbr>Param<wbr>Description</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/serversentevent.html" class="tsd-kind-icon">Server<wbr>Sent<wbr>Event</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/servicedescription.html" class="tsd-kind-icon">Service<wbr>Description</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/testresults.html" class="tsd-kind-icon">Test<wbr>Results</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/testsettings.html" class="tsd-kind-icon">Test<wbr>Settings</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/webserveroptions.html" class="tsd-kind-icon">Web<wbr>Server<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/webserviceoptions.html" class="tsd-kind-icon">Web<wbr>Service<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#certattributes" class="tsd-kind-icon">Cert<wbr>Attributes</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#encodingtype" class="tsd-kind-icon">Encoding<wbr>Type</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#middlewaredefinition" class="tsd-kind-icon">Middleware<wbr>Definition</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#protocol" class="tsd-kind-icon">Protocol</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#controller_classes" class="tsd-kind-icon">CONTROLLER_<wbr>CLASSES</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#controller" class="tsd-kind-icon">Controller</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#middleware" class="tsd-kind-icon">Middleware</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#webservice" class="tsd-kind-icon">Web<wbr>Service</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#getparameternames" class="tsd-kind-icon">get<wbr>Parameter<wbr>Names</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#body" class="tsd-kind-icon">Body</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#delete" class="tsd-kind-icon">Delete</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#get" class="tsd-kind-icon">Get</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#mount" class="tsd-kind-icon">Mount</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#options" class="tsd-kind-icon">Options</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#patch" class="tsd-kind-icon">Patch</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#pathparam" class="tsd-kind-icon">Path<wbr>Param</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#post" class="tsd-kind-icon">Post</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#put" class="tsd-kind-icon">Put</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#queryparam" class="tsd-kind-icon">Query<wbr>Param</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#request" class="tsd-kind-icon">Request</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#route" class="tsd-kind-icon">Route</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#sessionvalue" class="tsd-kind-icon">Session<wbr>Value</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#accesscontrol" class="tsd-kind-icon">access<wbr>Control</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#main" class="tsd-kind-icon">main</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#preparemiddleware" class="tsd-kind-icon">prepare<wbr>Middleware</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#runtest" class="tsd-kind-icon">run<wbr>Test</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#teststrap" class="tsd-kind-icon">teststrap</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>