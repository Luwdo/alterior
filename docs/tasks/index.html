<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>@alterior/tasks</title>
	<meta name="description" content="Documentation for @alterior/tasks">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">@alterior/tasks</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>@alterior/tasks</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#alteriortasks" id="alteriortasks" style="color: inherit; text-decoration: none;">
					<h1>@alterior/tasks</h1>
				</a>
				<p><a href="https://www.npmjs.com/package/@alterior/tasks"><img src="https://img.shields.io/npm/v/@alterior/tasks.svg" alt="Version"></a></p>
				<p>A framework for enqueuing and processing jobs from Redis queues in Typescript. Build background task runners with this. </p>
				<a href="#getting-started" id="getting-started" style="color: inherit; text-decoration: none;">
					<h2>Getting started</h2>
				</a>
				<p>Install the Alterior runtime, the DI library, and the tasks module:</p>
				<pre><code><span class="hljs-built_in">npm</span> install reflect-metadata
<span class="hljs-built_in">npm</span> install @alterior/runtime @alterior/di @alterior/tasks</code></pre>
				<a href="#a-minimal-example" id="a-minimal-example" style="color: inherit; text-decoration: none;">
					<h2>A minimal example</h2>
				</a>
				<p>First, build a task worker:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Worker } <span class="hljs-keyword">from</span> <span class="hljs-string">'@alterior/tasks'</span>;
<span class="hljs-keyword">import</span> { Logger } <span class="hljs-keyword">from</span> <span class="hljs-string">'@alterior/logger'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyTaskHost <span class="hljs-keyword">extends</span> Worker {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
        <span class="hljs-keyword">private</span> logger : Logger,
        <span class="hljs-keyword">private</span> taskRunner : TaskRunner
    </span>) {

    }
    <span class="hljs-keyword">get</span> name() { <span class="hljs-keyword">return</span> <span class="hljs-string">'@myorg/mypackage:MyTask'</span>; }

    <span class="hljs-keyword">async</span> transcodeToFormat({ videoId : <span class="hljs-built_in">string</span>, format : <span class="hljs-built_in">string</span> }) {
        <span class="hljs-keyword">this</span>.logger.info(<span class="hljs-string">'Transcoding to format...'</span>);
        run(<span class="hljs-string">`ffmpeg /storage/<span class="hljs-subst">${video}</span>.mp4`</span>);
    }

    <span class="hljs-keyword">async</span> transcode({ videoId : <span class="hljs-built_in">string</span> }) {
        <span class="hljs-keyword">this</span>.logger.info(<span class="hljs-string">'Queuing transcoding tasks...'</span>);

        <span class="hljs-keyword">this</span>.taskRunner.worker()

        <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.enqueue(<span class="hljs-string">'transcodeToFormat'</span>, { videoId: <span class="hljs-string">'abcdef'</span>, format: <span class="hljs-string">'1080p'</span> });
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.enqueue(<span class="hljs-string">'transcodeToFormat'</span>, { videoId: <span class="hljs-string">'abcdef'</span>, format: <span class="hljs-string">'720p'</span> });
    }
}</code></pre>
				<p>However, it is more scalable and type-safe to specify a task per class:</p>
				<pre><code class="language-typescript">
<span class="hljs-meta">@Task</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TranscodeToFormatTask <span class="hljs-keyword">extends</span> TaskRunner {
    execute() {
        run(<span class="hljs-string">`ffmpeg /storage/<span class="hljs-subst">${video}</span>.mp4`</span>);
    }
}

<span class="hljs-meta">@Task</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TranscodeTask <span class="hljs-keyword">extends</span> TaskRunner {
    execute() {
        <span class="hljs-keyword">await</span> TranscodeToFormatTask.enqueue({ videoId: <span class="hljs-string">'abcdef'</span>, format: <span class="hljs-string">'1080p'</span> });
    }
}

<span class="hljs-meta">@Module</span>({
    tasks: [ MyTask ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyModule {
}

Application.bootstrap(MyModule, [ TaskRunner ]);</code></pre>
				<a href="#building-your-app" id="building-your-app" style="color: inherit; text-decoration: none;">
					<h2>Building your app</h2>
				</a>
				<p>Make sure to enable <code>emitDecoratorMetadata</code> and <code>experimentalDecorators</code> in your project&#39;s <code>tsconfig.json</code>.</p>
				<a href="#delegation-via-mounting" id="delegation-via-mounting" style="color: inherit; text-decoration: none;">
					<h2>Delegation via Mounting</h2>
				</a>
				<p>You can delegate parts of your web service to dedicated controllers by mounting them within your main service class. Doing so will
					route specific URLs to specific controllers. Any controller can also <code>@Mount()</code>, providing an intuitive way to construct a
				complete web service.</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@WebService</span>(...)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyWebService <span class="hljs-keyword">implements</span> OnInit {
    <span class="hljs-meta">@Mount</span>(<span class="hljs-string">'/users'</span>)
    usersController : UsersController;

    <span class="hljs-meta">@Mount</span>(<span class="hljs-string">'/some-plugin'</span>)
    somePlugin : SomePluginController;
}</code></pre>
				<a href="#mechanics" id="mechanics" style="color: inherit; text-decoration: none;">
					<h2>Mechanics</h2>
				</a>
				<p>Mechanically, <code>@WebService()</code> declares the class as a module (<code>@Module()</code>), applies <code>@AppOptions()</code>, and registers itself as a controller class within that module.
				You can pass any of the options for <code>@Module()</code>, <code>@AppOptions()</code> as well as the options available for <code>WebServerModule.configure(...)</code>.</p>
				<p>The following definition is equivalent to using <code>@WebService(options?)</code>:</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@AppOptions</span>(options)
<span class="hljs-meta">@Module</span>({
    ...options,
    controllers: [ MyWebService ],
    imports: [ WebServerModule.configure(options) ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyWebService { <span class="hljs-comment">/* ... */</span> }</code></pre>
				<p>For a larger application, you may wish to separate your
				top-level module from your web service implementation, especially when your application serves multiple roles. </p>
				<pre><code class="language-typescript"><span class="hljs-comment">// app.module.ts</span>

<span class="hljs-keyword">import</span> { AppOptions } <span class="hljs-keyword">from</span> <span class="hljs-string">'@alterior/runtime'</span>;
<span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@alterior/di'</span>;
<span class="hljs-keyword">import</span> { WebServerModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@alterior/web-server'</span>;
<span class="hljs-keyword">import</span> { FooController } <span class="hljs-keyword">from</span> <span class="hljs-string">'./foo.controller'</span>;

<span class="hljs-meta">@AppOptions</span>({ name: <span class="hljs-string">'My Application'</span> })
<span class="hljs-meta">@Module</span>({
    imports: [ WebServerModule ],
    controllers: [ FooController ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppModule {
}</code></pre>
				<p>Note that we need to explicitly include the <code>WebServerModule</code> here.
				We can also configure that module here if desired:</p>
				<pre><code class="language-typescript">    imports: [ WebServerModule.configure({ port: <span class="hljs-number">1234</span>, ... }) ]</code></pre>
				<p>Now, let&#39;s create <code>FooController</code>, complete with a number of example routes so you can get an idea of the style:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// foo.controller.ts</span>

<span class="hljs-keyword">import</span> { Controller, Get, RouteEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">'@alterior/core'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;

<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'/optional-prefix'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FooController {
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/simple'</span>)
    <span class="hljs-keyword">public</span> simple(ev : RouteEvent)
    {
        <span class="hljs-keyword">return</span> { status: <span class="hljs-string">'success!'</span> };
    }

    <span class="hljs-comment">/**
     * You can also return promises.
     */</span>
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/promises'</span>)
    <span class="hljs-keyword">public</span> canHazPromises()
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve({ nifty: <span class="hljs-number">123</span> });
    }

    <span class="hljs-comment">/**
     * Or use async/await (the recommended way!)
     */</span>
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/async'</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> canHasAsync()
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> someFunction();
    }

    <span class="hljs-comment">/**
     * The parameters specified by your route methods are automatically analyzed,
     * and the correct value is provided depending on what type (and in some cases what name)
     * your parameter has.
     *
     * For example, you can get access to the Express request and response by injecting 
     * RouteEvent.
     */</span>
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/useRouteEvent'</span>)
    <span class="hljs-keyword">public</span> canHazRouteEvent(ev : RouteEvent)
    {
        ev.response.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">"/foo works!"</span>);
    }

    <span class="hljs-comment">/**
     * You can also request the Express request/response explicitly (note that this is 
     * based on the parameter name, see below for more details about
     * route method parameters).
     */</span>
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/bar'</span>)
    <span class="hljs-keyword">public</span> bar(req : express.Request, res : express.Response)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve({ nifty: <span class="hljs-number">123</span> });
    }

    <span class="hljs-comment">/**
     * Promises can reject with an HttpException to specify HTTP errors...
     */</span>
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/error'</span>)
    <span class="hljs-keyword">public</span> errorExample(req : express.Request, res : express.Response)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> HttpException(<span class="hljs-number">301</span>, {message: <span class="hljs-string">"No, over there"</span>}));
    }

    <span class="hljs-comment">/**
     * Or return an Alterior Response object for more flexibility...
     */</span>
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/specificResponse'</span>)
    <span class="hljs-keyword">public</span> specificResponseAndSuch(req : express.Request, res : express.Response)
    {
    <span class="hljs-keyword">return</span> Response.serverError({ message: <span class="hljs-string">`uh oh, that's never happened before`</span> });
    }

    <span class="hljs-comment">/**
     * You can even specify middleware directly on a route method...
     */</span>
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/middlewareRocks'</span>, {
        middleware: [ myGreatMiddleware(someParameters) ]
    })
    <span class="hljs-keyword">public</span> middlewareRolls(req : express.Request, res : express.Response)
    {
    <span class="hljs-keyword">return</span> Response.serverError({ message: <span class="hljs-string">`uh oh, that's never happened before`</span> });
    }

}</code></pre>
				<p>Finally, we would make a separate entry point (&quot;main&quot;) file:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// main.ts </span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'reflect-metadata'</span>;

<span class="hljs-keyword">import</span> { Application } <span class="hljs-keyword">from</span> <span class="hljs-string">'@alterior/runtime'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;

Application.bootstrap(AppModule);</code></pre>
				<a href="#route-parameters" id="route-parameters" style="color: inherit; text-decoration: none;">
					<h2>Route Parameters</h2>
				</a>
				<p>Alterior inspects the parameters of controller methods to determine what values to provide.
					First, parameters of type <code>RouteEvent</code> are fulfilled with an instance of that class which
				contains the Express request and response objects:</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@Get</span>(<span class="hljs-string">'/do'</span>)
doThings(ev : RouteEvent) {
    ev.response.status(<span class="hljs-number">404</span>).send(<span class="hljs-string">"Not found."</span>);
}</code></pre>
				<p>Parameters decorated with <code>@PathParam(&#39;a&#39;)</code> will be fulfilled with the value of path parameter <code>:a</code> from the route path. </p>
				<p>Parameters decorated with <code>@QueryParam(&#39;q&#39;)</code> will be fulfilled with the query parameter <code>q</code> if provided. </p>
				<p>Parameters which are named <code>body</code> or decorated with <code>@Body()</code> will be fulfilled with the value of <code>request.body</code>. You must use a body parsing middleware (we recommend <code>body-parser</code>) to populate <code>request.body</code>.</p>
				<p>When combined with value returns, you can achieve a very natural style:  </p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> bodyParser <span class="hljs-keyword">from</span> <span class="hljs-string">'body-parser'</span>;

<span class="hljs-keyword">interface</span> MyRequestType {
    action : <span class="hljs-built_in">string</span>;
    foo? : <span class="hljs-built_in">number</span>;
}

<span class="hljs-meta">@Controller</span>({ middleware: [ bodyParser.json() ] })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyController {
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/do/:action'</span>)
    doThings(
        <span class="hljs-meta">@Body</span>() body : MyRequestType, 
        <span class="hljs-meta">@PathParam</span>(<span class="hljs-string">'action'</span>) action : <span class="hljs-built_in">string</span>, 
        <span class="hljs-meta">@QueryParam</span>(<span class="hljs-string">'message'</span>) message : <span class="hljs-built_in">string</span>
    ) {
        <span class="hljs-keyword">return</span> {status: <span class="hljs-string">"success"</span>};
    }
}</code></pre>
				<a href="#httperror" id="httperror" style="color: inherit; text-decoration: none;">
					<h2><code>HttpError</code></h2>
				</a>
				<p>The <code>HttpError</code> class is included to signal Alterior to send certain HTTP status codes and responses back to the client when exceptional circumstances occur.</p>
				<pre><code class="language-typescript">    <span class="hljs-comment">// Perhaps we couldn't contact a microservice needed to fulfill the request.</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpError(<span class="hljs-number">502</span>, <span class="hljs-string">"Service is not available"</span>);</code></pre>
				<a href="#response" id="response" style="color: inherit; text-decoration: none;">
					<h2><code>Response</code></h2>
				</a>
				<p>Alterior includes a <code>Response</code> class that makes it easy to return any HTTP response from your method. You can use this instead of HTTP exceptions if you wish, so here&#39;s the same example using <code>Response</code>:</p>
				<pre><code class="language-typescript">    <span class="hljs-comment">// Perhaps we couldn't contact a microservice needed to fulfill the request.</span>
    <span class="hljs-keyword">return</span> Response.badGateway({ message: <span class="hljs-string">"Service is not available"</span> });</code></pre>
				<a href="#dependency-injection" id="dependency-injection" style="color: inherit; text-decoration: none;">
					<h2>Dependency Injection</h2>
				</a>
				<p>Modules, controllers and services all participate in dependency injection. For more information about how DI works in Alterior apps, see the documentation for <a href="../di/README.md">@alterior/di</a>.</p>
				<a href="#applying-middleware" id="applying-middleware" style="color: inherit; text-decoration: none;">
					<h2>Applying Middleware</h2>
				</a>
				<p>Since Alterior uses Express (<a href="https://expressjs.com/">https://expressjs.com/</a>), it supports any Express-compatible or Connect based middleware. Middleware can be used globally, it can be mounted to a specific set of URLs,  or it can be declared as part of a route, just like you can with vanilla Express.</p>
				<p>To add middleware globally you must use the <code>@AppOptions</code> decorator on your app class:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> bodyParser <span class="hljs-keyword">from</span> <span class="hljs-string">'body-parser'</span>; <span class="hljs-comment">// you will need to load the body-parser typings for this syntax</span>
<span class="hljs-meta">@AppOptions</span>({
    middleware: [bodyParser.json()]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Application {
    <span class="hljs-comment">// ...</span>
}</code></pre>
				<p>To add &quot;mounted&quot; middleware:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> fileUpload = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express-fileupload'</span>);

<span class="hljs-meta">@AppOptions</span>({
    middleware: [
        [<span class="hljs-string">'/files'</span>, fileUpload]
    ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Application {
    <span class="hljs-comment">// ...</span>
}</code></pre>
				<p>To add route-specific middleware:</p>
				<pre><code class="language-typescript">    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/foo'</span>, { middleware: [bodyParser.json()] })
    <span class="hljs-keyword">public</span> foo(req : express.Request, res : express.Response) {
        <span class="hljs-comment">// todo</span>
    }</code></pre>
				<a href="#uncaught-exceptions" id="uncaught-exceptions" style="color: inherit; text-decoration: none;">
					<h2>Uncaught Exceptions</h2>
				</a>
				<p>When an exception occurs while executing a controller route method (excluding HttpExceptions), Alterior will respond
					with an HTTP 500 error. By default, exception information will be included with the response. If the caught exception
					has a <code>toString()</code> method, it will be executed and its return value will be sent. If it does not, the error object will
				be included directly, being converted along with the rest of the response to JSON.</p>
				<p><code>throw new Error(&#39;This is the error text&#39;)</code> would produce:</p>
				<pre><code>{<span class="hljs-string">"message"</span>:<span class="hljs-string">"An exception occurred while handling this request."</span>,<span class="hljs-string">"error"</span>:<span class="hljs-comment">"Error: This is the error text                                                                 </span>
    at FooController.sampleRequest (music.<span class="hljs-keyword">j</span><span class="hljs-variable">s:36</span>:<span class="hljs-number">29</span>)<span class="hljs-comment">"}</span></code></pre><p><code>throw { foo: &#39;bar&#39; }</code> would product:</p>
				<pre><code>{<span class="hljs-attr">"message"</span>:<span class="hljs-string">"An exception occurred while handling this request."</span>,<span class="hljs-attr">"error"</span>:{<span class="hljs-attr">"foo"</span>:<span class="hljs-string">"bar"</span>}}</code></pre><p>You can disable the inclusion of exception information in responses (and this is recommended for production).
				To do so, set <code>AppOptions.hideExceptions</code> to <code>true</code>. The <code>error</code> field will then be excluded from 500 responses.</p>
				<pre><code>{<span class="hljs-attr">"message"</span>:<span class="hljs-string">"An exception occurred while handling this request."</span>}</code></pre>
				<a href="#sessions" id="sessions" style="color: inherit; text-decoration: none;">
					<h2>Sessions</h2>
				</a>
				<p>To add session support, use <code>express-session</code>:</p>
				<pre><code>npm i <span class="hljs-built_in">express</span>-session --<span class="hljs-built_in">save</span>
typings i dt~<span class="hljs-built_in">express</span>-session --<span class="hljs-built_in">save</span></code></pre><p>Include it as middleware:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> session <span class="hljs-keyword">from</span> <span class="hljs-string">'express-session'</span>;
<span class="hljs-meta">@AppOptions</span>({
    middleware: [session({ secret: SESSION_SECRET })]
})</code></pre>
				<p>You can then use the session by requesting it as a parameter from your controller methods:</p>
				<pre><code class="language-typescript">
<span class="hljs-keyword">interface</span> SessionData {
    username : <span class="hljs-built_in">string</span>;
    cartTotal : <span class="hljs-built_in">number</span>;
}

<span class="hljs-meta">@Controller</span>()
<span class="hljs-keyword">class</span> SampleController {
    <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/'</span>)
    home(session : SessionData) {
        <span class="hljs-keyword">return</span> session.cartTotal;
    }
}</code></pre>
				<p><a href="https://github.com/alterior-mvc/alterior-mongo">Alterior Mongo</a> alternatively provides a MongoDB-based session provider based on <code>connect-mongo</code>,
				or you can use any Express/Connect middleware that provides <code>request.session</code>.</p>
				<a href="#custom-services" id="custom-services" style="color: inherit; text-decoration: none;">
					<h2>Custom services</h2>
				</a>
				<p>To declare a service, simply mark it with <code>@Injectable()</code> from <code>@alterior/di</code> and then include it in the <code>providers</code> list of one of the Alterior module definitions within your application. The service will be made available across your whole application.</p>
				<a href="#accessing-the-express-instance" id="accessing-the-express-instance" style="color: inherit; text-decoration: none;">
					<h2>Accessing the Express instance</h2>
				</a>
				<p>Perhaps you need access to the Express application object to do something Alterior doesn&#39;t support:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span>
<span class="hljs-meta">@Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FooController {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
        <span class="hljs-keyword">private</span> expressRef : ExpressRef
    </span>) {
        <span class="hljs-keyword">this</span>.expressApp = expressRef.application;
        <span class="hljs-keyword">this</span>.expressApp.get(<span class="hljs-string">'/something'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
            res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">'/something works!'</span>);
        });
    }

    <span class="hljs-keyword">private</span> expressApp : express.Application;
}</code></pre>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class">
						<a href="classes/taskannotation.html" class="tsd-kind-icon">Task<wbr>Annotation</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/taskmoduleoptionsref.html" class="tsd-kind-icon">Task<wbr>Module<wbr>Options<wbr>Ref</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/taskqueueclient.html" class="tsd-kind-icon">Task<wbr>Queue<wbr>Client</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/taskrunner.html" class="tsd-kind-icon">Task<wbr>Runner</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/taskworker.html" class="tsd-kind-icon">Task<wbr>Worker</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/taskworkerproxy.html" class="tsd-kind-icon">Task<wbr>Worker<wbr>Proxy</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/taskworkerregistry.html" class="tsd-kind-icon">Task<wbr>Worker<wbr>Registry</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/tasksmodule.html" class="tsd-kind-icon">Tasks<wbr>Module</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/worker.html" class="tsd-kind-icon">Worker</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/constructor.html" class="tsd-kind-icon">Constructor</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/taskhandler.html" class="tsd-kind-icon">Task<wbr>Handler</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/taskjob.html" class="tsd-kind-icon">Task<wbr>Job</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/taskmoduleoptions.html" class="tsd-kind-icon">Task<wbr>Module<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/taskworkerentry.html" class="tsd-kind-icon">Task<wbr>Worker<wbr>Entry</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#joboptions" class="tsd-kind-icon">Job<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#promisewrap" class="tsd-kind-icon">Promise<wbr>Wrap</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#queue" class="tsd-kind-icon">Queue</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#queuejob" class="tsd-kind-icon">Queue<wbr>Job</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#queueoptions" class="tsd-kind-icon">Queue<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#remoteservice" class="tsd-kind-icon">Remote<wbr>Service</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#remoteworker" class="tsd-kind-icon">Remote<wbr>Worker</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#queue_options" class="tsd-kind-icon">QUEUE_<wbr>OPTIONS</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#task" class="tsd-kind-icon">Task</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>